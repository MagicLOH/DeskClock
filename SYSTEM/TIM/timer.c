#include "timer.h"

u16 ucOverFlowCnt = 0;
u16 g_usOvertimeFLAG = 0;
/*
****************************************************************************************************************
   
    函数原型:void TIMx_Initial(TIM_TypeDef * TIMx,u16 _usPSC,u16 _usARR)
    函数功能:定时器TIMx初始化
    函数形参:u16 _usPSC 预分频系数，u16 _usARR 自动重装载值
    硬件连接:无
    返回值:无
    
****************************************************************************************************************  
*/
void TIMx_Init(TIM_TypeDef * TIMx,u16 _usPSC,u16 _usARR)//APB2主频系数不为1则频率 * 2=72Mhz
{
    /*TIMx外设时钟使能*/
    if(TIMx == TIM2)//TIM2
    {
        RCC->APB1ENR  |= 1<<0;
        RCC->APB1RSTR |= 1<<0;//复位
        RCC->APB1RSTR &= ~(1<<0);
        CM3_NVIC_SetPriority(TIM2_IRQn,3,3);//设置中断优先级
    }
    else if(TIMx == TIM3)//TIM3
    {
        RCC->APB1ENR  |= 1<<1;
        RCC->APB1RSTR |= 1<<1;//复位
        RCC->APB1RSTR &= ~(1<<1);
        CM3_NVIC_SetPriority(TIM3_IRQn,3,3);//设置中断优先级
    }
    else if(TIMx == TIM4)//TIM4
    {
        RCC->APB1ENR  |= 1<<2;
        RCC->APB1RSTR |= 1<<2;//复位
        RCC->APB1RSTR &= ~(1<<2);
        CM3_NVIC_SetPriority(TIM4_IRQn,3,3);//设置中断优先级
    }
    else return;

    /*TIM3寄存器配置时基功能*/
        /*1.基本配置*/
    //TIM3->CR1 |= 1<<0;//使能计数器(废话)
    TIMx->CR1 &= ~(1<<1);//允许更新事件UEV的产生
    TIMx->CR1 |= 1<<2;   //只有计数器上溢/下溢才更新
    TIMx->CR1 |= 0<<3;   //"单脉冲模式" 1开/0关
    TIMx->CR1 |= 0<<4;   //计数器向上计数 
    TIMx->CR1 |= 0<<5;   //边沿对齐模式
    TIMx->CR1 |= 0<<6;   //同上
    TIMx->CR1 &= ~(1<<7);//设置寄存器没有缓冲
    TIMx->CR1 |= 0<<8;   //时钟分频因子为1
    TIMx->CR1 |= 0<<9;   //同上

        /*2.核心配置*/
    TIMx->CNT = 0;//计数从0开始计时
    TIMx->ARR = _usARR - 1;//计数最大达到65535结束，与分频值同步大小
    TIMx->PSC = _usPSC - 1;//预分频系数

        /*3.定时器中断配置*/
    TIMx->DIER = 1<<0;//允许更新中断
        
        /*4.定时器失能*/
    TIMx->CR1 &= ~(1<<0);
}

/*
****************************************************************************************************************
   
    函数原型:void TIM2_IRQHandler(void)
    函数功能:TIM2定时器中断服务例程
    函数形参:无
    硬件连接:无
    返回值:无
    
****************************************************************************************************************  
*/
void TIM2_IRQHandler(void)
{
    if(TIM2->SR & 1<<0)
    {
        TIM2->CR1 &= ~(1<<0);//定时器失能

        TIM2->SR &= ~(1<<0); //手动清除更新事件
    }
}

/*
****************************************************************************************************************
   
    函数原型:void TIM3_IRQHandler(void)
    函数功能:TIM3定时器中断服务例程
    函数形参:无
    硬件连接:无
    返回值:无
    
****************************************************************************************************************  
*/
void TIM3_IRQHandler(void)
{
    //首先判断中断类型(溢出、UG位、...)
    if(TIM3->SR & 1<<0) //判断是否有更新事件产生
    {
        TIM3->CR1 &= ~(1<<0);//定时器失能
        g_ucUsart1RXFLAG = 1;//缓冲区数据可用
        g_ucUsart3Buff[g_ucUsart3Cnt] = '\0';
        TIM3->SR &= ~(1<<0); //手动清除更新事件
    }

}

/*
****************************************************************************************************************
   
    函数原型:void TIM3_IRQHandler(void)
    函数功能:TIM3定时器中断服务例程
    函数形参:无
    硬件连接:无
    返回值:无
    
****************************************************************************************************************  
*/
void TIM4_IRQHandler(void)
{
    //首先判断中断类型(溢出、UG位、从模式控制器产生的更新)
    if(TIM4->SR & 1<<0) //判断是否有更新事件产生
    {
        TIM4->CR1 &= ~(1<<0);//定时器失能
        g_ucUsart3RXFLAG = 1;//缓冲区数据可用
        g_ucUsart3Buff[g_ucUsart3Cnt] = '\0';
        TIM4->SR &= ~(1<<0); //手动清除更新事件
    }

}

