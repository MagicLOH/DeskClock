#include "ds18b20.h"

static u8 DS18B20_Reset(void);
static void DS18B20_Wr_Byte(u8 _ucTxd);
static u8 DS18B20_Rd_Byte(void);
float DS18B20_GetTemperature(void);
/*
****************************************************************************************************************
   
    函数原型: u8 DS18B20_Initial(void)
    函数功能: DS18B20温采传感器 初始化
    函数形参: 无
    硬件连接: DS18B20_DQ - PB15 -通用开漏输出模式
    返 回 值: 复位值 0成功 1/2失败
    
****************************************************************************************************************  
*/
u8 DS18B20_Init(void)
{
    /*GPIO相关初始化*/
    RCC->APB2ENR |= 1<<3;//GPIOB时钟使能
    GPIOB->CRH |= 0x0FFFFFFF;//设置为通用开漏输出模式
    GPIOB->CRH |= 0x70000000;
    GPIOB->ODR |= 1<<15;//手动拉高总线电平

    return DS18B20_Reset();//返回复位值
}

/*
****************************************************************************************************************
    
    函数原型: static u8 DS18B20_Reset(void)
    函数功能: DS18B20 复位
    函数形参: 无
    硬件连接: 无
    返 回 值: 0成功 1/2失败

****************************************************************************************************************  
*/
static u8 DS18B20_Reset(void)
{
    u16 Overtime = 0;//设置超时时间
    /*主机主动将总线拉低持续至少 480μs 来产生一个复位脉冲。之后需要主动释放(拉高)总线*/
    DS18B20_DQ_OUT = 0;
    delay_us(480);
    DS18B20_DQ_OUT = 1;
    //当主机主动发送复位脉冲后，如果能立即收到一个存在脉冲，那就表明 DS18B20 已经准备好发送和接收数据了
    while(Overtime < 80)//等待从设备拉低总线--(60<Overtime<240)
    {

        delay_us(1);
        Overtime++;
        if(DS18B20_DQ_IN == 0) break;//从机拉低电平的到来
    }
    if(Overtime == 80) return 1;//pulse receive fail
    Overtime = 0;
    while(Overtime < 280)//等待从设备自动释放（由外部上拉电阻拉高）总线--(240<Overtime<null)
    {
        delay_us(1);
        Overtime++;
        if(DS18B20_DQ_IN == 1) break;//从机释放(拉高)电平的到来
    }
    if (Overtime == 280) return 2;//pulse receive fail

    return 0;//success
}

/*
****************************************************************************************************************
    
    函数原型: static void DS18B20_Wr_Byte(u8 _ucTxd)
    函数功能: 向DS18B20写字节
    函数形参: u8 _ucTxd 写入执行温转等功能的指令0xXX
    硬件连接: 无
    返 回 值: 无
    注意：单个写时间隙周期至少持续 60μs，且每个数据位之间需要实现至少 1us 的释放间隔

****************************************************************************************************************  
*/
static void DS18B20_Wr_Byte(u8 _ucTxd)
{
    //当主机主动将总线拉低（至少维持 1us）时，"写时间隙"开始
    for(u8 i=0;i<8;i++)
    {
        DS18B20_DQ_OUT = 0 ; //拉低
        delay_us(3);         //维持 3us "写时间隙"开始
        if(_ucTxd & 0x01)
            DS18B20_DQ_OUT = 1;//写1
        else
            DS18B20_DQ_OUT = 0;//写0
        /*DS18B20 将在"写时间隙"开始的一个[15μs~60μs]的窗口内对总线上的电平状态进行采样*/
        delay_us(60);       //则一个写周期需要60us以上
        DS18B20_DQ_OUT =1 ; //主机把总线电平拉高
        delay_us(3);        //且每个数据位之间需要实现至少 1us 的释放间隔
        _ucTxd >>= 1;       //右移一位准备写入下一位
    } 
}

/*
****************************************************************************************************************
    
    函数原型: static u8 DS18B20_Rd_Byte(u8 _ucRxd)
    函数功能: 向DS18B20读字节
    函数形参: u8 _ucRxd 待读入的数据
    硬件连接: 无
    返 回 值: _ucRxd 读到的8bit数据
    DS18B20 将在"读时间隙"开始的一个[15μs~60μs]的窗口内对总线上的电平状态进行采样

****************************************************************************************************************  
*/
static u8 DS18B20_Rd_Byte(void)
{   
    u8 _ucRxd = 0;
    //当主机主动将总线拉低（至少维持 1us）时，"读时间隙"开始
    for(u8 i=0;i<8;i++)
    {
        DS18B20_DQ_OUT = 0 ;//拉低
        delay_us(3);//维持3us "读时间隙"开始
        /*随后 DS18B20 将会在读时间隙开始的 15μs 内完成对总线电平状态的修改\
        （因此主机必须在读时间隙开始后立即释放总线）*/
        DS18B20_DQ_OUT = 1;
        /*为了确保读取到正常的数据，主机必须在读时间隙开始的 15μs 内完成对总线数据的读取*/
        delay_us(10);//为从设备修改总线电平状态预留时间
        if(DS18B20_DQ_IN)//如果为高电平--可读
            _ucRxd |= 1<<i;//该位读1 -- 置1
        else
            _ucRxd &= ~(1<<i);//读0 -- 清0
        /*DS18B20 将在"读时间隙"开始的一个[15μs~60μs]的窗口内对总线上的电平状态进行采样*/
        delay_us(60);//则一个读周期需要60us以上
        //DS18B20_DQ_OUT =1 ; //主机把总线电平拉高
        //delay_us(3);        //且每个数据位之间需要实现至少 1us 的释放间隔
    } 
    
    return _ucRxd;
}
/*
****************************************************************************************************************
    
    函数原型: float DS18B20_GetTemperature(void)
    函数功能: 从D18B20中获取温度数据 (读到数据)
    函数形参: 无
    硬件连接: 无
    返 回 值: 获取到的温度值

****************************************************************************************************************  
*/
float DS18B20_GetTemperature(void)
{
    u8 TempH,TempL;
    u16 _Temp;
    
    DS18B20_Reset();//初始化序列
    DS18B20_Wr_Byte(0xCC);/*Skip ROM [CCh] 
                            可以主机可以通过该指令同时寻址总线上所有
                            设备而无需发送任何 ROM 编码。例如，主机可以
                            令总线上所有 DS18B20 同时执行温度转换，只需
                            发布 Skip ROM 指令跟随一个 Convert T [44h] 
                            指令。*/
    DS18B20_Wr_Byte(0x44);/*发动一次温度转换。转换之后，采集的
                            热数据存储在暂存器中的 2 字节的温度寄存器然后
                            DS18B20 返回低功耗空闲状态*/
    while (!DS18B20_Rd_Byte()); //忙状态时，全0
    
    DS18B20_Reset();            //初始化序列
    DS18B20_Wr_Byte(0xCC);      //跳过ROM
    DS18B20_Wr_Byte(0xBE);      //令允许主机读取暂存器中的内容
    TempL = DS18B20_Rd_Byte();  //先高后低
    TempH = DS18B20_Rd_Byte();

    _Temp = TempH << 8 | TempL; 
    if(TempH > 7)//1111 1100 1011 0001
    {
        _Temp = ~_Temp;//0000 0011 0100 1110
        _Temp += 1; //0000 0011 0100 1111
    }
    return (_Temp * 0.0625);
}
